// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//struct to hold individual ship data
struct ShipData
{
    float3 position;
    float3 velocity;
    float3 movePosition;
    float heading;
};

//parameters
int numShips; //total number of ships
int entity; //index of the entity the graph is made for in EntityMgr.inst.entities
int entCommands; //number of commands in the main ent
float maxMag; //maximum magnitude of potentials to be represented on the graph

struct PotentialParameters
{
    float waypointCoefficient;
    float waypointExponent;
    float attractiveCoefficient;
    float attractiveExponent;
    float repulsiveCoefficient;
    float repulsiveExponent;
    float attractiveBearingAngle;
    float attractiveBearingAngleExp;
    float attractiveBearingCoefficient;
    float attractiveBearingExponent;
    float attractiveTAAngle;
    float attractiveTAAngleExp;
    float attractiveTACoefficient;
    float attractiveTAExponent;
    float repulsiveBearingAngle;
    float repulsiveBearingAngleExp;
    float repulsiveBearingCoefficient;
    float repulsiveBearingExponent;
    float repulsiveTAAngle;
    float repulsiveTAAngleExp;
    float repulsiveTACoefficient;
    float repulsiveTAExponent;
};

RWStructuredBuffer<float3> positions; //buffer to hold mesh vertex positions
StructuredBuffer<ShipData> ships; //buffer to hold indvidual ship data
StructuredBuffer<PotentialParameters> potential; //buffer to hold potential parameters

//Same as the Vector3.normalize method in unity
float3 NormalizeVector(float3 vec)
{
    float mag = sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
    float3 newVec = float3(vec.x / mag, vec.y / mag, vec.z / mag);
    return newVec;
}

//Same as the Vector3.magnitude method in unity
float VectorMagnitude(float3 vec)
{
    return sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
}

//some Mathf constants
#define PI 3.14159265358979323846
#define Deg2Rad (PI * 2) / 360.0
#define Rad2Deg 360 / (PI * 2)

//ensures that degree values are between 0 and 360
float Degrees360(float angleDegrees)
{
    float ad = angleDegrees;
    while (ad >= 360)
    {
        ad -= 360;
    }
    while (ad < 0)
    {
        ad += 360;
    }
    return ad;

}

//coverts a vector to head
float VectorToHeadingDegrees(float3 v)
{
    return atan2(v.x, v.z) * Rad2Deg;
}

//gets difference between angles
float AngleDiffPosNeg(float a, float b)
{
    float diff = a - b;
    if (diff > 180)
        return diff - 360;
    if (diff < -180)
        return diff + 360;
    return diff;
}

float CalculatePotential(float3 position, int entity)
{
    float magnitude = 0;
    
    PotentialParameters pf = potential[0];
    
    float3 attractiveDist = ships[entity].movePosition - position;
    float3 attractivePotential = NormalizeVector(attractiveDist) * 
        pf.waypointCoefficient * pow(VectorMagnitude(attractiveDist), pf.waypointExponent);
    
    float3 repField = 0;
    float3 attField = 0;
    float3 attCrossPosField = 0;
    float3 attCrossVelField = 0;
    float3 repCrossPosField = 0;
    float3 repCrossVelField = 0;
    
    float3 starboard = NormalizeVector(cross(ships[entity].velocity, float3(0, -1, 0)));
    
    for (int i = 0; i < numShips; i++)
    {
        if (i == entity)
            continue;
        
        float3 posDiff = ships[i].position - position;
        float3 relVel = ships[i].velocity - ships[entity].velocity;
        
        float3 entPosDiff = ships[i].position - ships[entity].position;
        float relBearing = atan2(entPosDiff.x, entPosDiff.z) * Rad2Deg - ships[entity].heading;
        float3 negEntPosDiff = ships[entity].position - ships[i].position;
        float targetAngle = atan2(negEntPosDiff.x, negEntPosDiff.z) * Rad2Deg - ships[i].heading;
        
        float attBAngle = sin((relBearing + pf.attractiveBearingAngle) * Deg2Rad);
        float attTAngle = sin((targetAngle + pf.attractiveTAAngle) * Deg2Rad);
        
        float repBAngle = sin((relBearing + pf.repulsiveBearingAngle) * Deg2Rad);
        float repTAngle = sin((targetAngle + pf.repulsiveTAAngle) * Deg2Rad);
        
        repField = repField + (pow(VectorMagnitude(posDiff), pf.repulsiveExponent) * pf.repulsiveCoefficient * -NormalizeVector(posDiff));
        attField = attField + (pow(VectorMagnitude(posDiff), pf.attractiveExponent) * pf.attractiveCoefficient * NormalizeVector(posDiff));
        attCrossPosField = attCrossPosField + (pow((0.5 * (attBAngle + 1)), pf.attractiveBearingAngleExp) * pow(VectorMagnitude(entPosDiff), pf.attractiveBearingExponent) * pf.attractiveBearingCoefficient * starboard);
        attCrossVelField = attCrossVelField + (pow((0.5 * (attTAngle + 1)), pf.attractiveTAAngleExp) * pow(VectorMagnitude(entPosDiff), pf.attractiveTAExponent) * pf.attractiveTACoefficient * starboard);
        repCrossPosField = repCrossPosField + (pow((0.5 * (attBAngle + 1)), pf.repulsiveBearingAngleExp) * pow(VectorMagnitude(entPosDiff), pf.repulsiveBearingExponent) * pf.repulsiveBearingCoefficient * -starboard);
        repCrossVelField = repCrossVelField + (pow((0.5 * (attTAngle + 1)), pf.repulsiveTAAngleExp) * pow(VectorMagnitude(entPosDiff), pf.repulsiveTAExponent) * pf.repulsiveTACoefficient * -starboard);
    }
    
    float3 starboardPosition = ships[entity].position + (300 * starboard);
    
    float starboardDistance = 0;
    starboardDistance = VectorMagnitude(starboardPosition - position);
    
    magnitude = -VectorMagnitude(attractivePotential) + VectorMagnitude(repField) - VectorMagnitude(attField);
    if (starboardDistance < 100)
    {
        magnitude = magnitude - VectorMagnitude(attCrossPosField + attCrossVelField);
        magnitude = magnitude + VectorMagnitude(repCrossPosField + repCrossVelField);
    }
    magnitude = clamp(magnitude, -maxMag, maxMag);
    
    
    return magnitude;
}


[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float3 pos = positions[id.x];
    pos.y = 0;
    float mag = (CalculatePotential(pos, entity) / maxMag) * 400;
    positions[id.x] = float3(pos.x, mag, pos.z);
}
