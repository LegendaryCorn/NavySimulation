// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//struct to hold individual ship data
struct ShipData
{
    float3 position;
    float3 velocity;
    float3 movePosition;
    float heading;
};

//parameters
int numShips; //total number of ships
int entity; //index of the entity the graph is made for in EntityMgr.inst.entities
int entCommands; //number of commands in the main ent
float maxMag; //maximum magnitude of potentials to be represented on the graph

//parameters to toggle fields
bool calcWaypoint;
bool calcRepField;
bool calcAttField;
bool calcCrossPosField;
bool calcCrossVelField;

bool directional;

struct PotentialParameters
{
    float waypointCoefficient;
    float waypointExponent;
    float attractiveCoefficient;
    float attractiveExponent;
    float repulsiveCoefficient;
    float repulsiveExponent;
    float bearingAngle;
    float bearingAngleExp;
    float bearingCoefficient;
    float bearingExponent;
    float taAngle;
    float taAngleExp;
    float taCoefficient;
    float taExponent;
};

RWStructuredBuffer<float3> positions; //buffer to hold mesh vertex positions
StructuredBuffer<ShipData> ships; //buffer to hold indvidual ship data
StructuredBuffer<PotentialParameters> potential; //buffer to hold potential parameters

//Same as the Vector3.normalize method in unity
float3 NormalizeVector(float3 vec)
{
    float mag = sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
    if (mag != 0)
    {
        float3 newVec = float3(vec.x / mag, vec.y / mag, vec.z / mag);
        return newVec;
    }
    else
        return float3(0, 0, 0);
    
}

//Same as the Vector3.magnitude method in unity
float VectorMagnitude(float3 vec)
{
    return sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
}

//some Mathf constants
#define PI 3.14159265358979323846
#define Deg2Rad (PI * 2) / 360.0
#define Rad2Deg 360 / (PI * 2)

//ensures that degree values are between 0 and 360
float Degrees360(float angleDegrees)
{
    float ad = angleDegrees;
    while (ad >= 360)
    {
        ad -= 360;
    }
    while (ad < 0)
    {
        ad += 360;
    }
    return ad;

}

//coverts a vector to head
float VectorToHeadingDegrees(float3 v)
{
    return atan2(v.x, v.z) * Rad2Deg;
}

//gets difference between angles
float AngleDiffPosNeg(float a, float b)
{
    float diff = a - b;
    if (diff > 180)
        return diff - 360;
    if (diff < -180)
        return diff + 360;
    return diff;
}

float CalculatePotential(float3 position, int entity)
{
    float magnitude = 0;
    
    PotentialParameters pf = potential[0];
    
    float3 attractiveDist = ships[entity].movePosition - position;
    float3 attractivePotential = NormalizeVector(attractiveDist) * 
        pf.waypointCoefficient * pow(VectorMagnitude(attractiveDist), pf.waypointExponent);
    
    float3 repField = 0;
    float3 attField = 0;
    float3 crossPosField = 0;
    float3 crossVelField = 0;
    
    float3 starboard = NormalizeVector(cross(ships[entity].velocity, float3(0, -1, 0)));
    
    for (int i = 0; i < numShips; i++)
    {
        if (i == entity)
            continue;
        
        float3 posDiff = ships[i].position - position;
        float3 relVel = ships[i].velocity - ships[entity].velocity;
        
        float3 entPosDiff = ships[i].position - ships[entity].position;
        float relBearing = atan2(entPosDiff.x, entPosDiff.z) * Rad2Deg - ships[entity].heading;
        float3 negEntPosDiff = ships[entity].position - ships[i].position;
        float targetAngle = atan2(negEntPosDiff.x, negEntPosDiff.z) * Rad2Deg - ships[i].heading;
        
        float bAngle = sin((relBearing + pf.bearingAngle) * Deg2Rad);
        float tAngle = sin((targetAngle + pf.taAngle) * Deg2Rad);
        
        repField = repField + (pow(VectorMagnitude(posDiff), pf.repulsiveExponent) * pf.repulsiveCoefficient * -NormalizeVector(posDiff));
        attField = attField + (pow(VectorMagnitude(posDiff), pf.attractiveExponent) * pf.attractiveCoefficient * NormalizeVector(posDiff));
        crossPosField = crossPosField + (pow((0.5 * (bAngle + 1)), pf.bearingAngleExp) * pow(VectorMagnitude(entPosDiff), pf.bearingExponent) * pf.bearingCoefficient * starboard);
        crossVelField = crossVelField + (pow((0.5 * (tAngle + 1)), pf.taAngle) * pow(VectorMagnitude(entPosDiff), pf.taExponent) * pf.taCoefficient * starboard);
    }
    
    float3 starboardPosition = ships[entity].position + (300 * starboard);
    
    float starboardDistance = 0;
    starboardDistance = VectorMagnitude(starboardPosition - position);
    
    if(calcWaypoint)
        magnitude = magnitude - VectorMagnitude(attractivePotential);
    if(calcRepField)
        magnitude = magnitude + VectorMagnitude(repField);
    if(calcAttField)
        magnitude = magnitude - VectorMagnitude(attField);
    
    if (starboardDistance < 100)
    {
        if(calcCrossPosField)
            magnitude = magnitude - VectorMagnitude(crossPosField);
        if(calcCrossVelField)
            magnitude = magnitude - VectorMagnitude(crossVelField);
    }
    magnitude = clamp(magnitude, -maxMag, maxMag);
    
    
    return magnitude;
}

float CalcPotVector(float3 position, int entity)
{
    float3 potentialTotal = float3(0, 0, 0);
    float magnitude = 0;
    
    PotentialParameters pf = potential[0];
    
    float3 attractiveDist = ships[entity].movePosition - position;
    float3 attractivePotential = NormalizeVector(attractiveDist) *
        pf.waypointCoefficient * pow(VectorMagnitude(attractiveDist), pf.waypointExponent);
    
    float3 repField = 0;
    float3 attField = 0;
    float3 crossPosField = 0;
    float3 crossVelField = 0;
    
    float3 starboard = NormalizeVector(cross(ships[entity].velocity, float3(0, -1, 0)));
    
    for (int i = 0; i < numShips; i++)
    {
        if (i == entity)
            continue;
        
        float3 posDiff = ships[i].position - position;
        float3 relVel = ships[i].velocity - ships[entity].velocity;
        
        float3 entPosDiff = ships[i].position - ships[entity].position;
        float relBearing = atan2(entPosDiff.x, entPosDiff.z) * Rad2Deg - ships[entity].heading;
        float3 negEntPosDiff = ships[entity].position - ships[i].position;
        float targetAngle = atan2(negEntPosDiff.x, negEntPosDiff.z) * Rad2Deg - ships[i].heading;
        
        float bAngle = sin((relBearing + pf.bearingAngle) * Deg2Rad);
        float tAngle = sin((targetAngle + pf.taAngle) * Deg2Rad);
        
        repField = repField + (pow(VectorMagnitude(posDiff), pf.repulsiveExponent) * pf.repulsiveCoefficient * -NormalizeVector(posDiff));
        attField = attField + (pow(VectorMagnitude(posDiff), pf.attractiveExponent) * pf.attractiveCoefficient * NormalizeVector(posDiff));
        crossPosField = crossPosField + (pow((0.5 * (bAngle + 1)), pf.bearingAngleExp) * pow(VectorMagnitude(entPosDiff), pf.bearingExponent) * pf.bearingCoefficient * starboard);
        crossVelField = crossVelField + (pow((0.5 * (tAngle + 1)), pf.taAngle) * pow(VectorMagnitude(entPosDiff), pf.taExponent) * pf.taCoefficient * starboard);
    }
    
    if(calcWaypoint)
        potentialTotal = potentialTotal + attractivePotential;
    if(calcRepField)
        potentialTotal = potentialTotal + repField;
    if(calcAttField)
        potentialTotal = potentialTotal + attField;
    if(calcCrossPosField)
        potentialTotal = potentialTotal + crossPosField;
    if(calcCrossVelField)
        potentialTotal = potentialTotal + crossVelField;
    
    float3 fieldCenter = ships[entity].position + (NormalizeVector(potentialTotal) * 300);
    
    float fieldDistance = VectorMagnitude(fieldCenter - position);
    
    if (fieldDistance < 100)
    {
        magnitude = -VectorMagnitude(potentialTotal);
    }
    
    magnitude = clamp(magnitude, -maxMag, maxMag);
    
    return magnitude;
}


[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float3 pos = positions[id.x];
    pos.y = 0;
    float mag;
    if(!directional)
        mag = (CalculatePotential(pos, entity) / maxMag) * 400;
    else
        mag = (CalcPotVector(pos, entity) / maxMag) * 400;
    positions[id.x] = float3(pos.x, mag, pos.z);
}
